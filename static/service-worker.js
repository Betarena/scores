// @ts-nocheck

importScripts("https://progressier.app/A0K7kzxcIrOaWtW8h3Ol/sw.js");

/// <reference lib="webworker" />


// import
// {
//   build,
//   files,
//   version
// } from '$service-worker';

const build = []; // Replace with the actual build files array if available
const files = []; // Replace with the actual static files array if available
const version = '1.0'; // Define the version appropriately
const worker =
  self;
const FILES = `cache${version}`;
const VIDEO_CACHE = `video${version}`;

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = build.concat(files);
const staticAssets = new Set(to_cache);

worker.addEventListener('install', (event) =>
{
  event.waitUntil(
    caches
      .open(FILES)
      .then((cache) => cache.addAll(to_cache))
      .then(() =>
      {
        worker.skipWaiting();
      })
  );
});

worker.addEventListener('activate', (event) =>
{
  event.waitUntil(
    caches.keys().then(async (keys) =>
    {
      // delete old caches
      for (const key of keys)
      {
        if (key !== FILES && key !== VIDEO_CACHE)
          await caches.delete(key);
      }

      worker.clients.claim();
    })
  );
});

/**
 * Fetch the asset from the network and store it in the cache.
 * Fall back to the cache if the user is offline.
 */
async function fetchAndCache(request)
{
  const cache = await caches.open(
    `offline${version}`
  );

  try
  {
    const response = await fetch(request);
    cache.put(request, response.clone());
    return response;
  } catch (err)
  {
    const response = await cache.match(request);
    if (response) return response;

    throw err;
  }
}

// ╭─────
// │ NOTE: Parse a Range header like "bytes=0-1023" into { start, end }.
// │ Returns null if the header is absent or cannot be parsed.
// ╰─────
function parseRange(rangeHeader, totalLength)
{
  if (!rangeHeader) return null;

  const match = rangeHeader.match(/^bytes=(\d*)-(\d*)$/);
  if (!match) return null;

  let start = match[1] !== '' ? parseInt(match[1], 10) : null;
  let end   = match[2] !== '' ? parseInt(match[2], 10) : null;

  // suffix range: bytes=-500 → last 500 bytes
  if (start === null)
  {
    start = Math.max(0, totalLength - end);
    end = totalLength - 1;
  }
  else
  {
    end = end !== null ? Math.min(end, totalLength - 1) : totalLength - 1;
  }

  return { start, end };
}

// ╭─────
// │ NOTE: Handle a video request with full caching + Range support.
// │ Strategy:
// │   1. If the full video is already cached → slice and return 206.
// │   2. If not cached yet → fetch the full video (no Range), cache it,
// │      then slice and return 206 (or 200 for non-range requests).
// ╰─────
async function handleVideoRequest(event)
{
  const cache  = await caches.open(VIDEO_CACHE);
  const rangeHeader = event.request.headers.get('range');

  // ╭─────
  // │ NOTE: Always look up the cache by the bare URL (no Range header).
  // ╰─────
  const cacheKey = new Request(event.request.url);
  const cached   = await cache.match(cacheKey);

  let buffer;

  if (cached)
  {
    buffer = await cached.arrayBuffer();
  }
  else
  {
    // Fetch without Range so we get the full file and can cache it.
    const fullResponse = await fetch(event.request.url);

    if (!fullResponse.ok)
      return fullResponse;

    buffer = await fullResponse.arrayBuffer();

    // Store as a plain 200 response in cache.
    const headers = new Headers();
    headers.set('Content-Type', fullResponse.headers.get('content-type') ?? 'video/mp4');
    headers.set('Content-Length', String(buffer.byteLength));
    headers.set('Accept-Ranges', 'bytes');

    await cache.put(cacheKey, new Response(buffer.slice(0), { status: 200, headers }));
  }

  const totalLength = buffer.byteLength;

  if (!rangeHeader)
  {
    // Non-range request (e.g. initial metadata probe on some browsers).
    return new Response(buffer,
    {
      status: 200,
      headers:
      {
        'Content-Type': 'video/mp4',
        'Content-Length': String(totalLength),
        'Accept-Ranges': 'bytes',
        'Cache-Control': 'public, max-age=86400',
      },
    });
  }

  const range = parseRange(rangeHeader, totalLength);

  if (!range || range.start > range.end || range.start >= totalLength)
  {
    return new Response('Range Not Satisfiable',
    {
      status: 416,
      headers: { 'Content-Range': `bytes */${totalLength}` },
    });
  }

  const chunk = buffer.slice(range.start, range.end + 1);

  return new Response(chunk,
  {
    status: 206,
    headers:
    {
      'Content-Type': 'video/mp4',
      'Content-Length': String(chunk.byteLength),
      'Content-Range': `bytes ${range.start}-${range.end}/${totalLength}`,
      'Accept-Ranges': 'bytes',
      'Cache-Control': 'public, max-age=86400',
    },
  });
}

worker.addEventListener('fetch', (event) =>
{
  if (event.request.method !== 'GET')
    return;

  const url = new URL(event.request.url);

  // ╭─────
  // │ NOTE: Video proxy routes — handle with full cache + Range support.
  // ╰─────
  if (
    url.host === self.location.host &&
    url.pathname.startsWith('/video/')
  )
  {
    event.respondWith(handleVideoRequest(event));
    return;
  }

  // ╭─────
  // │ NOTE: Skip Range requests for everything else (browser handles them).
  // ╰─────
  if (event.request.headers.has('range'))
    return;

  // don't try to handle e.g. data: URIs
  const isHttp = url.protocol.startsWith('http');
  const isDevServerRequest =
    url.hostname === self.location.hostname &&
    url.port !== self.location.port;
  const isStaticAsset =
    url.host === self.location.host &&
    staticAssets.has(url.pathname);
  const skipBecauseUncached =
    event.request.cache === 'only-if-cached' &&
    !isStaticAsset;
  // ... adding a `not-same-origin` check for `requests`
  // ... more info -> https://stackoverflow.com/questions/48463483/what-causes-a-failed-to-execute-fetch-on-serviceworkerglobalscope-only-if
  const skipBecauseNotSameOrigin =
    event.request.mode !== 'same-origin';

  if (
    isHttp &&
    !isDevServerRequest &&
    !skipBecauseUncached &&
    !skipBecauseNotSameOrigin
  )
  {
    event.respondWith(
      (async () =>
      {
        // always serve static files and bundler-generated assets from cache.
        // if your application has other URLs with data that will never change,
        // set this variable to true for them and they will only be fetched once.
        const cachedAsset =
          isStaticAsset &&
          (await caches.match(event.request));

        return (
          cachedAsset ||
          fetchAndCache(event.request)
        );
      })()
    );
  }
});
